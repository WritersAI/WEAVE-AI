# WEAVE-AI Multi-Target Deploy Refactor Plan

## Summary

Add a multi-target deployment system that builds the plugin to multiple Obsidian vaults simultaneously during development. This eliminates the need for manual copying and enables rapid iteration across test vaults.

---

## Current State Analysis

### Existing Build System
- **Entry point**: `main.ts` (root level, ~1750 lines)
- **Build tool**: esbuild via `esbuild.config.mjs`
- **Output**: `main.js`, `styles.css`, `manifest.json`
- **Dev workflow**: `npm run dev` → watch mode → outputs to project root
- **No deployment mechanism** — relies on vault symlinks or manual copy

### What REFACTOR.md Proposes
1. A `.targets/` directory with subdirectories per vault
2. A `targets.yaml` mapping target names to vault paths
3. Symlinks from `.targets/<name>` → vault plugins directory
4. Build outputs deployed to all (or selected) targets

### Problems with the EXTERNAL_PLAN
The external plan from REFACTOR.md assumed:
- A different directory structure (`src/` entry point)
- Different esbuild config
- JSON for targets (we'll use YAML as you specified)
- Symlink-based approach that can conflict with how Obsidian hot-reloads plugins

---

## Recommended Approach

### Use Direct Copy, Not Symlinks

**Rationale:**
- Obsidian's hot-reload (via `.hotreload` file) works best with actual files in the plugins directory
- Symlinks to a shared build target can cause file-watching issues
- Direct copy is simpler and more reliable
- You mentioned memex vault is already symlinked — nested symlinks are fragile

### How It Works
1. esbuild builds to project root (current behavior)
2. A post-build script copies `main.js`, `styles.css`, `manifest.json` to each configured vault
3. In watch mode, each rebuild triggers the copy automatically

---

## Implementation Plan

### Phase 1: Create Target Management Script

The system starts with **no targets configured**. Users add targets via the `target:add` command.

**Create `scripts/init-target.mjs`:**
```javascript
#!/usr/bin/env node
// Usage: node scripts/init-target.mjs <name> <vault-path>
// Adds target to .targets/targets.yaml and creates the plugin directory

import { readFileSync, writeFileSync, mkdirSync, existsSync } from 'fs';
import { resolve, dirname } from 'path';
import { fileURLToPath } from 'url';
import { parse as parseYaml, stringify as stringifyYaml } from 'yaml';

const __dirname = dirname(fileURLToPath(import.meta.url));
const rootDir = resolve(__dirname, '..');
const configPath = resolve(rootDir, '.targets/targets.yaml');

const [,, name, vaultPath] = process.argv;

if (!name || !vaultPath) {
  console.error('Usage: node scripts/init-target.mjs <name> <vault-path>');
  console.error('Example: node scripts/init-target.mjs woods /Users/ross/projects/woods-project');
  process.exit(1);
}

// Compute plugin path
const pluginPath = resolve(vaultPath.replace(/^~/, process.env.HOME), '.obsidian/plugins/weave-ai');

// Load or create config
let config = { targets: {}, default: null };
if (existsSync(configPath)) {
  config = parseYaml(readFileSync(configPath, 'utf8'));
}

// Add target
config.targets[name] = pluginPath;

// Set as default if first target
if (!config.default) {
  config.default = name;
}

// Ensure .targets directory exists
mkdirSync(resolve(rootDir, '.targets'), { recursive: true });

// Write config
writeFileSync(configPath, stringifyYaml(config));

// Create plugin directory
mkdirSync(pluginPath, { recursive: true });

// Create .hotreload file for Obsidian hot-reload
writeFileSync(resolve(pluginPath, '.hotreload'), '');

console.log(`✓ Added target "${name}": ${pluginPath}`);
console.log(`✓ Created plugin directory with .hotreload`);
if (Object.keys(config.targets).length === 1) {
  console.log(`✓ Set "${name}" as default target`);
}
```

**Create `.targets/targets.yaml.example`:**
```yaml
# WEAVE-AI Deploy Targets
# This file is auto-generated by `npm run target:add`
# Format: target_name: /absolute/path/to/vault/.obsidian/plugins/weave-ai

targets:
  # example: /Users/you/vaults/my-vault/.obsidian/plugins/weave-ai

# Default target for single-deploy commands (set automatically to first target added)
default: null
```

**Add to `.gitignore`:**
```
.targets/targets.yaml
```

### Phase 2: Create Deploy Script

**Create `scripts/deploy.mjs`:**
```javascript
#!/usr/bin/env node
import { readFileSync, copyFileSync, mkdirSync, existsSync } from 'fs';
import { resolve, dirname } from 'path';
import { fileURLToPath } from 'url';
import { parse as parseYaml } from 'yaml';

const __dirname = dirname(fileURLToPath(import.meta.url));
const rootDir = resolve(__dirname, '..');

// Parse arguments
const args = process.argv.slice(2);
const targetArg = args.find(a => !a.startsWith('--'));
const watchMode = args.includes('--watch');
const allTargets = args.includes('--all');

// Load config
const configPath = resolve(rootDir, '.targets/targets.yaml');

// Check if config exists
if (!existsSync(configPath)) {
  console.log('No deploy targets configured.');
  console.log('Add a target with: npm run target:add <name> <vault-path>');
  console.log('Example: npm run target:add woods /Users/ross/projects/woods-project');
  process.exit(0); // Exit cleanly, not an error
}

const config = parseYaml(readFileSync(configPath, 'utf8'));
const { targets, default: defaultTarget } = config;

// Check if any targets exist
if (!targets || Object.keys(targets).length === 0) {
  console.log('No deploy targets configured.');
  console.log('Add a target with: npm run target:add <name> <vault-path>');
  process.exit(0);
}

// Determine which targets to deploy to
let deployTargets;
if (allTargets) {
  deployTargets = Object.entries(targets);
} else if (targetArg) {
  if (!targets[targetArg]) {
    console.error(`Unknown target: ${targetArg}. Available: ${Object.keys(targets).join(', ')}`);
    process.exit(1);
  }
  deployTargets = [[targetArg, targets[targetArg]]];
} else if (defaultTarget && targets[defaultTarget]) {
  deployTargets = [[defaultTarget, targets[defaultTarget]]];
} else {
  console.log('No default target set. Use --all or specify a target name.');
  console.log(`Available targets: ${Object.keys(targets).join(', ')}`);
  process.exit(0);
}

// Files to deploy
const files = ['main.js', 'styles.css', 'manifest.json'];

// Deploy function
function deploy() {
  if (deployTargets.length === 0) return;

  for (const [name, path] of deployTargets) {
    const destPath = path.replace(/^~/, process.env.HOME);
    mkdirSync(destPath, { recursive: true });

    for (const file of files) {
      const src = resolve(rootDir, file);
      if (existsSync(src)) {
        copyFileSync(src, resolve(destPath, file));
      }
    }
    console.log(`✓ Deployed to ${name}: ${destPath}`);
  }
}

// Export for use by esbuild plugin
export { deploy, watchMode };

// Run if called directly
if (!watchMode) {
  deploy();
}
```

### Phase 3: Integrate with esbuild Watch Mode

**Modify `esbuild.config.mjs`:**
```javascript
import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = (process.argv[2] === "production");
const deployTarget = process.argv[3]; // Optional: specific target
const deployAll = process.argv.includes('--all');

// Dynamic import for deploy (only in dev mode)
let deployFn = null;
if (!prod) {
  try {
    const { deploy } = await import('./scripts/deploy.mjs');
    deployFn = deploy;
  } catch (e) {
    console.warn('Deploy script not found, skipping deployment');
  }
}

// Deploy plugin for watch mode
const deployPlugin = {
  name: 'deploy',
  setup(build) {
    build.onEnd(result => {
      if (result.errors.length === 0 && deployFn) {
        deployFn();
      }
    });
  }
};

const context = await esbuild.context({
  banner: { js: banner },
  entryPoints: ["main.ts"],
  bundle: true,
  external: [
    "obsidian",
    "electron",
    "@codemirror/autocomplete",
    "@codemirror/collab",
    "@codemirror/commands",
    "@codemirror/language",
    "@codemirror/lint",
    "@codemirror/search",
    "@codemirror/state",
    "@codemirror/view",
    "@lezer/common",
    "@lezer/highlight",
    "@lezer/lr",
    ...builtins
  ],
  format: "cjs",
  target: "es2018",
  logLevel: "info",
  sourcemap: prod ? false : "inline",
  treeShaking: true,
  outfile: "main.js",
  minify: prod,
  plugins: prod ? [] : [deployPlugin],
});

if (prod) {
  await context.rebuild();
  process.exit(0);
} else {
  await context.watch();
}
```

### Phase 4: Add npm Scripts

**Update `package.json` scripts:**
```json
{
  "scripts": {
    "dev": "node esbuild.config.mjs",
    "dev:all": "node esbuild.config.mjs --all",
    "build": "tsc -noEmit -skipLibCheck && node esbuild.config.mjs production",
    "deploy": "node scripts/deploy.mjs",
    "deploy:all": "node scripts/deploy.mjs --all",
    "target:add": "node scripts/init-target.mjs",
    "version": "node version-bump.mjs && git add manifest.json versions.json"
  }
}
```

### Phase 5: Add yaml Dependency

```bash
npm install --save-dev yaml
```

---

## File Changes Summary

| File | Action | Description |
|------|--------|-------------|
| `scripts/init-target.mjs` | Create | Target management script (add new vaults) |
| `scripts/deploy.mjs` | Create | Deploy script with target selection |
| `.targets/targets.yaml.example` | Create | Template for new setups |
| `esbuild.config.mjs` | Modify | Add deploy plugin for watch mode |
| `package.json` | Modify | Add deploy and target:add scripts |
| `.gitignore` | Modify | Add `.targets/targets.yaml` |

**Note:** `.targets/targets.yaml` is NOT created initially — it's auto-generated when you run `npm run target:add`.

---

## Usage After Implementation

### First Time Setup (No Targets)

```bash
# Add your first vault target
npm run target:add cwr /Users/ross/projects/cwr-novel

# Add more targets
npm run target:add woods /Users/ross/projects/woods-project
```

### Daily Development

```bash
# Development with auto-deploy to default target
npm run dev

# Development with auto-deploy to all targets
npm run dev:all

# One-time deploy to specific target
npm run deploy cwr

# One-time deploy to all targets
npm run deploy:all

# Production build (no deploy)
npm run build
```

---

## Notes for memex Vault

Since memex has existing symlink complexity:
1. Only build to the local `.targets/` directory
2. User will manually create symlink from memex to the local build

---

## Rollback Plan

If issues arise, simply:
1. Delete `scripts/deploy.mjs` and `scripts/init-target.mjs`
2. Revert `esbuild.config.mjs` to current version
3. Remove deploy/target scripts from `package.json`
4. Delete `.targets/` directory
5. Continue using manual copy or symlinks

The plugin code itself is unchanged.
